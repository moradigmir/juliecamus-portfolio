/**
 * Force proxy mapping for ALL preview/full URLs (grid + lightbox).
 * Ensures exact working shape with /public/ prefix and owner=juliecamus.
 */
export function toProxyStrict(input: string): string {
  // Convert proxy URLs to local paths
  if (input.includes('/hidrive-proxy?')) {
    try {
      const u = new URL(input);
      const p = u.searchParams.get('path') || '';
      // Convert /public/XX/file to /media/hidrive/XX/file
      const match = p.match(/\/public\/(\d+)\/(.*)/);
      if (match) {
        return `/media/hidrive/${match[1]}/${match[2]}`;
      }
      return p;
    } catch {
      return input;
      // fall through to rebuild from scratch
    }
  }

  // Accept raw path, hidrive://, or full URL. We only keep the PATH part.
  let p = (input || '').trim();

  // If it's a full URL, keep only pathname starting at /public
  try {
    if (p.startsWith('http')) {
      const u = new URL(p);
      p = u.pathname; // keep path only
    }
  } catch {}

  // Convert hidrive:// -> /
  if (p.startsWith('hidrive://')) p = p.replace('hidrive://','/');

  // Ensure leading slash
  if (!p.startsWith('/')) p = '/' + p;

  // If it doesn't start with /public/, prefix it
  if (!/^\/public\//i.test(p)) p = '/public' + p;

  // Normalize multiple slashes
  p = p.replace(/\/{2,}/g,'/');

  // Convert /public/XX/file to /media/hidrive/XX/file
  const match = p.match(/\/public\/(\d+)\/(.*)/);
  if (match) {
    return `/media/hidrive/${match[1]}/${match[2]}`;
  }
  return p;
}

// Legacy alias for backward compatibility
export const toProxy = toProxyStrict;

// Type definitions matching HiDriveBrowser
export interface HiDriveItem {
  name: string;
  type: 'file' | 'directory';
  size?: number;
  modified?: string;
  contentType?: string;
}

export interface ProbeResult {
  ok: boolean;
  status: number;
  contentType: string;
}

// Detect if Supabase services are paused (similar to HiDriveBrowser logic)
const detectSupabaseIssueFromResponse = (status: number, contentType: string): boolean => {
  if (status === 503) return true;
  if (status >= 500 && status < 600) return true;
  if (contentType.includes('text/html') && status !== 200) return true;
  return false;
};

// Check if content type is media (images or video)
export const isMediaContentType = (ct: string): boolean => 
  ct.startsWith('video/') || ct.startsWith('image/');

/**
 * List directory contents - returns empty array since we don't need listing for local files
 */
export const listDir = async (path: string): Promise<HiDriveItem[]> => {
  return [];
};

/**
 * Probe a file URL using GET+Range (not HEAD) to check if it streams properly.
 * Returns ok if status is 200/206 and content-type is image/* or video/*.
 */
export async function probeStream(urlOrPath: string) {
  const u = toProxyStrict(urlOrPath);
  const res = await fetch(u, { headers: { Range: 'bytes=0-1' } });
  const result = { ok: res.ok || res.status === 206, status: res.status, ct: res.headers.get('content-type') || undefined, url: u };
  
  // Log successful range probe with diagnostics
  if (result.status === 206 || result.status === 200) {
    const { diag } = await import('../debug/diag');
    const pathMatch = u.match(/path=([^&]+)/);
    const path = pathMatch ? decodeURIComponent(pathMatch[1]) : urlOrPath;
    diag('NET', 'range_probe', { path, status: result.status, ct: result.ct });
  }
  
  return result;
}

/**
 * Find a poster image for a folder (preview.webp, preview.jpg, preview.png).
 * Returns proxied URL if found, null otherwise.
 */
export const findPosterForFolder = async (path: string): Promise<string | null> => {
  try {
    const items = await listDir(path);
    const posterExtensions = ['webp', 'jpg', 'jpeg', 'png'];
    const posterFile = items.find(item => {
      const nameLower = item.name.toLowerCase();
      return posterExtensions.some(ext => nameLower === `preview.${ext}`);
    });
    
    if (posterFile) {
      const posterUrl = `https://fvrgjyyflojdiklqepqt.functions.supabase.co/hidrive-proxy?path=${encodeURIComponent(path + posterFile.name)}&owner=juliecamus`;
      console.log('üñºÔ∏è Found poster', { folder: path, file: posterFile.name });
      return posterUrl;
    }
    
    return null;
  } catch (error) {
    console.error('‚ùå Failed to find poster', path, error);
    return null;
  }
};

/**
 * Find a preview file for a folder using directory listing.
 * Prefers preview.* files (case-insensitive), prioritizes video over images for preview.
 * Falls back to first video, then first media file by lexicographic order.
 */
export const findPreviewForFolder = async (path: string): Promise<string | null> => {
  try {
    // Convert /public/XX/ to /media/hidrive/XX/
    const pathMatch = path.match(/\/public\/(\d+)\/(.*)/);
    if (pathMatch) {
      const localPath = `/media/hidrive/${pathMatch[1]}/`;
      
      // Try common preview files
      const previewFiles = ['preview.mp4', 'preview.mov', 'preview.webm', 'preview.m4v', 'preview.jpg', 'preview.jpeg', 'preview.png', 'preview.webp'];
      
      for (const previewFile of previewFiles) {
        try {
          const response = await fetch(localPath + previewFile);
          if (response.ok) {
            return localPath + previewFile;
          }
        } catch {
          // Continue to next
        }
      }
    }
    
    return null;
    
  } catch (error) {
    console.error('‚ùå Failed to find preview for folder', path, error);
    return null;
  }
};

/**
 * Find the first video file in a folder, returning its proxied URL.
 * Returns null if no video files are found.
 */
export const findFirstVideoForFolder = async (path: string): Promise<string | null> => {
  try {
    const items = await listDir(path);
    const videoFiles = items.filter(item => 
      item.type === 'file' && 
      item.contentType?.startsWith('video/')
    );
    
    if (videoFiles.length === 0) {
      return null;
    }
    
    // Return first video by lexicographic order
    const firstVideo = videoFiles.sort((a, b) => a.name.localeCompare(b.name))[0];
    const videoUrl = `https://fvrgjyyflojdiklqepqt.functions.supabase.co/hidrive-proxy?path=${encodeURIComponent(path + firstVideo.name)}&owner=juliecamus`;
    console.log('üé¨ Found first video', { folder: path, file: firstVideo.name, url: videoUrl });
    return videoUrl;
  } catch (error) {
    console.error('‚ùå Failed to find video in folder', path, error);
    return null;
  }
};

export interface ValidateResult {
  ok: boolean;
  preview?: string;
}

/**
 * Validate a folder by finding its preview and testing if it streams properly.
 * Returns {ok:true, preview:file} if valid, {ok:false} otherwise.
 */
/**
 * List directory contents without media filtering (for manifest search).
 */
const listDirAll = async (path: string): Promise<HiDriveItem[]> => {
  const normalized = path.endsWith('/') ? path : path + '/';
  
  const url = new URL('https://fvrgjyyflojdiklqepqt.functions.supabase.co/hidrive-proxy');
  url.searchParams.set('path', normalized);
  url.searchParams.set('list', '1');
  url.searchParams.set('owner', 'juliecamus');
  
  const res = await fetch(url.toString(), { method: 'GET' });
  const ct = res.headers.get('content-type') || '';
  
  if (detectSupabaseIssueFromResponse(res.status, ct)) {
    throw new Error(`Supabase paused (${res.status})`);
  }
  
  if (!(res.ok || res.status === 207)) {
    throw new Error(`HTTP ${res.status}: ${ct}`);
  }
  
  const xml = await res.text();
  const parser = new DOMParser();
  const doc = parser.parseFromString(xml, 'application/xml');
  const responses = Array.from(doc.getElementsByTagNameNS('*', 'response'));

  const items: HiDriveItem[] = [];
  for (const r of responses) {
    const hrefEl = r.getElementsByTagNameNS('*', 'href')[0];
    if (!hrefEl) continue;
    
    let href = hrefEl.textContent || '';
    try { href = decodeURIComponent(href); } catch { }
    
    const pathOnly = href.replace(/^https?:\/\/[^/]+/, '');
    if (!pathOnly) continue;
    
    const normNoSlash = normalized.replace(/\/$/, '');
    const pathNoSlash = pathOnly.replace(/\/$/, '');
    if (pathNoSlash === normNoSlash) continue;

    const segments = pathOnly.split('/').filter(Boolean);
    const name = segments.pop() || '';

    const isDir = r.getElementsByTagNameNS('*', 'collection').length > 0;
    const typeEl = r.getElementsByTagNameNS('*', 'getcontenttype')[0];
    const sizeEl = r.getElementsByTagNameNS('*', 'getcontentlength')[0];
    const modEl = r.getElementsByTagNameNS('*', 'getlastmodified')[0];
    const contentType = (typeEl?.textContent || '').toLowerCase();
    const size = sizeEl ? parseInt(sizeEl.textContent || '0', 10) : undefined;
    const modified = modEl?.textContent || undefined;

    if (isDir) {
      items.push({ name, type: 'directory' });
    } else {
      // Include ALL files, not just media
      items.push({ name, type: 'file', size, modified, contentType });
    }
  }
  
  const unique = new Map<string, HiDriveItem>();
  for (const it of items) unique.set(it.name.toLowerCase(), it);
  return Array.from(unique.values()).sort((a, b) => a.name.localeCompare(b.name));
};

/**
 * Fetch text content from a path using the HiDrive proxy with cache-busting.
 */
export const fetchText = async (path: string, noStore = true): Promise<string | null> => {
  try {
    // Convert /public/XX/file to /media/hidrive/XX/file
    const pathMatch = path.match(/\/public\/(\d+)\/(.*)/);
    if (pathMatch) {
      const localPath = `/media/hidrive/${pathMatch[1]}/${pathMatch[2]}`;
      
      try {
        const response = await fetch(localPath);
        if (response.ok) {
          const text = await response.text();
          if (text && text.trim()) {
            // Only reject if it's actually HTML
            const trimmed = text.trim();
            if (trimmed.startsWith('<html') || trimmed.startsWith('<!DOCTYPE')) {
              return null;
            } else {
              return text;
            }
          }
        }
      } catch {
        return null;
      }
    }
    
    return null;
  } catch (error) {
    return null;
  }
};

/**
 * Find and fetch MANIFEST file in a folder (case-insensitive, multiple formats).
 * Tries: MANIFEST.md, MANIFEST.txt, MANIFEST, README.md, INFO.md
 * Returns { content, matchedFilename } if found, null if not found.
 */
export const findManifestMarkdown = async (folderPath: string): Promise<{ content: string; matchedFilename: string } | null> => {
  try {
    // Ensure trailing slash
    const normalizedPath = folderPath.endsWith('/') ? folderPath : folderPath + '/';
    
    // Priority order: MANIFEST variants first, then README/INFO as low-priority fallback
    const manifestVariants = [
      'MANIFEST.md', 'Manifest.md', 'manifest.md',
      'MANIFEST.txt', 'Manifest.txt', 'manifest.txt',
      'MANIFEST', 'Manifest', 'manifest',
      'README.md', 'INFO.md'
    ];
    
    // Convert /public/XX/ to /media/hidrive/XX/
    const folderMatch = normalizedPath.match(/\/public\/(\d+)\//);
    if (folderMatch) {
      const localPath = `/media/hidrive/${folderMatch[1]}/`;
      
      for (const variant of manifestVariants) {
        try {
          const response = await fetch(localPath + variant);
          if (response.ok) {
            const content = await response.text();
            if (content && content.trim()) {
              // Only reject if it's actually HTML (starts with < tag)
              const trimmed = content.trim();
              if (trimmed.startsWith('<')) {
                continue; // Skip HTML files
              }
              return { content, matchedFilename: variant };
            }
          }
        } catch {
          // Continue to next variant
        }
      }
    }
    
    return null;
  } catch (error) {
    console.error('‚ùå Failed to find manifest', { folderPath, error });
    return null;
  }
};

/**
 * Parse MANIFEST content for metadata.
 * Supports: YAML front-matter, plain text (first line = title, paragraph = description), key-value pairs.
 */
export const parseManifestMarkdown = (md: string): { title?: string; description?: string; tags?: string[] } => {
  try {
    if (!md || !md.trim()) return {};
    
    // Reject HTML content (error pages)
    const trimmed = md.trim();
    if (trimmed.startsWith('<html') || trimmed.startsWith('<!DOCTYPE')) {
      console.warn('‚ö†Ô∏è parseManifestMarkdown: Rejecting HTML content', { startsWith: trimmed.substring(0, 50) });
      return {};
    }
    
    // Check for YAML front-matter
    if (md.startsWith('---')) {
      const endIndex = md.indexOf('---', 3);
      if (endIndex > 3) {
        const yamlContent = md.slice(3, endIndex).trim();
        const restContent = md.slice(endIndex + 3).trim();
        
        console.log('üîç Parsing YAML manifest', { yamlContent: yamlContent.substring(0, 100) });
        
        // Simple YAML parsing for our supported fields
        const result: { title?: string; description?: string; tags?: string[] } = {};
        
        const lines = yamlContent.split('\n');
        for (const line of lines) {
          const trimmed = line.trim();
          if (trimmed.startsWith('title:')) {
            result.title = trimmed.slice(6).trim().replace(/^["']|["']$/g, '');
          } else if (trimmed.startsWith('description:') || trimmed.startsWith('subtitle:')) {
            const key = trimmed.startsWith('description:') ? 'description:' : 'subtitle:';
            result.description = trimmed.slice(key.length).trim().replace(/^["']|["']$/g, '');
          } else if (trimmed.startsWith('tags:')) {
            const tagsStr = trimmed.slice(5).trim();
            if (tagsStr.startsWith('[') && tagsStr.endsWith(']')) {
              try {
                result.tags = JSON.parse(tagsStr);
              } catch {
                // Fallback: split by comma
                result.tags = tagsStr.slice(1, -1).split(',').map(t => t.trim().replace(/^["']|["']$/g, ''));
              }
            }
          }
        }
        
        console.log('‚úÖ Parsed manifest result', { title: result.title, description: result.description?.substring(0, 50), tags: result.tags });
        return result;
      }
    }
    
    // Plain text parsing
    const lines = md.split('\n').map(l => l.trim()).filter(l => l);
    if (lines.length === 0) return {};
    
    // Filter out HTML lines
    const filteredLines = lines.filter(line => 
      !line.startsWith('<html') && 
      !line.startsWith('<!DOCTYPE') &&
      !line.startsWith('<head') &&
      !line.startsWith('<body') &&
      !line.includes('</html>') &&
      !line.includes('</head>') &&
      !line.includes('</body>')
    );
    
    if (filteredLines.length === 0) return {};
    
    const result: { title?: string; description?: string; tags?: string[] } = {};
    
    // Try key-value format first (Title:, Description:, Tags:)
    let hasKeyValue = false;
    for (const line of filteredLines) {
      const colonIndex = line.indexOf(':');
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim().toLowerCase();
        const value = line.slice(colonIndex + 1).trim();
        
        if (key === 'title' && value) {
          result.title = value;
          hasKeyValue = true;
        } else if ((key === 'description' || key === 'subtitle') && value) {
          result.description = value;
          hasKeyValue = true;
        } else if (key === 'tags' && value) {
          // Try parsing as JSON array or comma-separated
          try {
            if (value.startsWith('[')) {
              result.tags = JSON.parse(value);
            } else {
              result.tags = value.split(',').map(t => t.trim()).filter(t => t);
            }
          } catch {
            result.tags = value.split(',').map(t => t.trim()).filter(t => t);
          }
          hasKeyValue = true;
        }
      }
    }
    
    if (hasKeyValue) return result;
    
    // Markdown format fallback
    // Find first H1
    const h1Line = filteredLines.find(line => line.startsWith('# '));
    if (h1Line) {
      result.title = h1Line.slice(2).trim();
    } else {
      // First non-empty line as title
      if (filteredLines[0]) {
        result.title = filteredLines[0];
      }
    }
    
    // Find first non-empty paragraph (not starting with #, at least 10 chars)
    const paragraph = filteredLines.find(line => 
      line && 
      !line.startsWith('#') && 
      !line.includes(':') && 
      line.length >= 10 &&
      line !== result.title
    );
    if (paragraph) {
      result.description = paragraph;
    } else if (filteredLines.length > 1 && filteredLines[1] && filteredLines[1] !== result.title) {
      // Second line as description if exists
      result.description = filteredLines[1];
    }
    
    return result;
  } catch (error) {
    console.error('‚ùå Failed to parse manifest', error);
    return {};
  }
};

/**
 * Get folder metadata by finding and parsing MANIFEST.md.
 */
export const getFolderMetadata = async (folderPath: string): Promise<{ title?: string; description?: string; tags?: string[] }> => {
  try {
    const manifestResult = await findManifestMarkdown(folderPath);
    if (!manifestResult) {
      // Emit diagnostics for missing manifest
      const { diag } = await import('../debug/diag');
      const folderNum = folderPath.replace(/.*\/public\/(\d+).*/, '$1');
      diag('MANIFEST', 'manifest_md_missing', { folder: folderNum });
      return {};
    }
    
    const { content, matchedFilename } = manifestResult;
    
    try {
      const metadata = parseManifestMarkdown(content);
      
      // Always emit diagnostics for successful parsing (regardless of content)
      const { diag, flushDiagToEdge, buildDiagSummary } = await import('../debug/diag');
      const folderNum = folderPath.replace(/.*\/public\/(\d+).*/, '$1');
      
      diag('MANIFEST', 'manifest_md_ok', { 
        folder: folderNum, 
        file: matchedFilename,
        title: metadata.title || '',
        descriptionLen: metadata.description?.length || 0
      });
      
      // Always flush to edge for each successful parse
      flushDiagToEdge(buildDiagSummary({ 
        manifest_example_0: { folder: folderNum, title: metadata.title || '' }
      }));
      
      // Persist the metadata to cache
      persistFolderMetaToCache(folderNum, metadata);
      
      return metadata;
    } catch (parseError) {
      // Emit diagnostics for parse errors
      const { diag } = await import('../debug/diag');
      const folderNum = folderPath.replace(/.*\/public\/(\d+).*/, '$1');
      diag('MANIFEST', 'manifest_md_error', { 
        folder: folderNum, 
        reason: parseError instanceof Error ? parseError.message : 'Parse error'
      });
      return {};
    }
  } catch (error) {
    // Emit diagnostics for general errors
    const { diag } = await import('../debug/diag');
    const folderNum = folderPath.replace(/.*\/public\/(\d+).*/, '$1');
    diag('MANIFEST', 'manifest_md_error', { 
      folder: folderNum, 
      reason: error instanceof Error ? error.message : 'Unknown error'
    });
    return {};
  }
};

export function persistFolderMetaToCache(folder: string, meta: any) {
  try {
    const OWNER = "juliecamus";
    const KEY = (o: string) => `manifestMetaCache:v2:${o}`;
    const raw = localStorage.getItem(KEY(OWNER));
    const old = raw ? JSON.parse(raw) : { owner: OWNER, updatedAt: 0, metaByFolder: {} };
    old.owner = OWNER;
    old.metaByFolder = old.metaByFolder || {};
    
    // Support negative cache with __absent marker and provenance
    if (meta && meta.__absent) {
      old.metaByFolder[folder] = { __absent: true, source: 'absent', ts: Date.now() };
      console.log("[HARD-DIAG:MANIFEST] manifest_absent_cached", { folder });
    } else {
      old.metaByFolder[folder] = { ...(old.metaByFolder[folder] ?? {}), ...(meta ?? {}), source: 'file', ts: Date.now() };
      console.log("[HARD-DIAG:MANIFEST] manifest_meta_persisted", { folder, source: "file" });
    }
    
    old.updatedAt = Date.now();
    localStorage.setItem(KEY(OWNER), JSON.stringify(old));
  } catch (e) {
    console.log("[HARD-DIAG:MANIFEST] persist_failed", { folder, err: String(e) });
  }
}


export const validateFolder = async (folderPath: string): Promise<ValidateResult> => {
  try {
    const previewUrl = await findPreviewForFolder(folderPath);
    if (!previewUrl) {
      console.log('‚ùå Folder FAIL', { folder: folderPath, reason: 'No preview found' });
      return { ok: false };
    }

    const probeResult = await probeStream(previewUrl);
    if (probeResult.ok) {
      // Extract filename from URL for logging
      const match = previewUrl.match(/path=([^&]+)/);
      const filename = match ? decodeURIComponent(match[1]).split('/').pop() : 'unknown';
      console.log('‚úÖ Folder OK', { folder: folderPath, file: filename });
      return { ok: true, preview: filename };
    } else {
      console.log('‚ùå Folder FAIL', { folder: folderPath, reason: `Probe failed: ${probeResult.status}` });
      return { ok: false };
    }
  } catch (error) {
    console.log('‚ùå Folder FAIL', { folder: folderPath, reason: error instanceof Error ? error.message : 'Unknown error' });
    return { ok: false };
  }
};
